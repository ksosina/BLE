---
title: "Baltimore Life Expectancy"
author: "Kayode Sosina"
date: "September 12, 2016"
output: html_document
references:
- id: mantel
  title: "The Mantel Test versus Pearson's Correlation Analysis: Assessment of the Differences for Biological and Environmental Studies"
  author:
  - family: Dutilleul
    given: Pierre  
  - family: Stockwell 
    given: Jason 
  - family: Frigon
    given: Dominic
  - family: Legendre
    given: Pierre
  container-title: "Journal of Agricultural, Biological, and Environmental Statistics"
  volume: 5
  URL: 'http://www.jstor.org/stable/1400528'
  publisher: "International Biometric Society"
  page: 131-150
  type: article-journal
  issued:
    year: 2000
    month: 6
- id: moran
  title: "Notes on Continuous Stochastic Phenomena"
  author:
  - family: Moran
    given: "Patrick Alfred Pierce"
  container-title: "Biometrika"
  volume: 37
  URL: 'http://www.jstor.org/stable/2332142'
  publisher: " Oxford University Press on behalf of Biometrika Trust"
  page: 17-23
  type: article-journal
  issued:
    year: 1950
    month: 6
- id: mantel1
  title: "The Detection of Disease Clustering and a Generalized Regression Approach"
  author:
  - family: Mantel
    given: "Nathan"
  container-title: "American Association for Cancer Research."
  type: article-journal
  issued:
    year: 1966
    month: 9
- id: fother
  title: "Geographically Weighted Regression: The Analysis of Spatially Varying Relationships"
  author:
  - family: Fotheringham
    given: "A. Stewart"
  - family: Brunsdon
    given: "Chris"
  - family: Charlton
    given: "Martin"
  container-title: " Wiley"
  type: Book
  issued:
    year: 2002
- id: who
  title: "An overarching health indicator for the Post-2015 Development Agenda"
  URL: 'http://www.who.int/healthinfo/indicators/hsi_indicators_SDG_TechnicalMeeting_December2015_BackgroundPaper.pdf'
  type: Article
  issued:
    year: 2014
- id: hdi
  title: "An overarching health indicator for the Post-2015 Development Agenda"
  URL: 'http://hdr.undp.org/en/content/human-development-index-hdi'
- id: gwmodel
  title: "GWmodel: An R Package for Exploring Spatial Heterogeneity Using Geographically Weighted Models"
  author:
  - family: Gollini
    given: Isabella  
  - family: Lu 
    given: Binbin 
  - family: Charlton
    given: Martin
  - family: Brunsdon
    given: Christopher
  - family: Harris
    given: Paul
  container-title: "Journal of Statistical softwar"
  volume: 63
  URL: 'http://dx.doi.org/10.18637/jss.v063.i17'
  type: article-journal
  issued:
    year: 2015
    month: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Introduction
-------------------

Life expectancy is a measure of how long an individual is expected to live on average and is commonly used in designing policy or even as a social indicator to evaluate the quality of life for any given region [see @who; also @hdi].

The goal of this project is to develop a model for predicting life expectancy in Baltimore down to single block resolution with estimates of uncertainty. The hope is that with this new information we would be able to better examine what factors contribute to the life expectancy for any given block in any given neighborhood in Baltimore city and so aid decision making when policy changes are being implemented. 

We have data gotten from the city of Baltimore which gives estimates of life expectancy at the Community statistical area (CSA) level. This was done since the boundaries, and the names of the 270+ neighborhoods in Baltimore may change over time. Thus the CSA provides a consistent way to characterize a particular region of the city. Each CSA is made up of several neighborhoods and these neighborhoods may belong to more than CSA. I.e., the boundaries of a CSA may go through a neighborhood.

Since our outcome, life expectancy, is gotten at an aggregate level. This project aims to provide a street block prediction of the expected life expectancy using statistical downscaling methods.

```{r housekeeping, include=FALSE, message=FALSE, eval=T}
source(file = file.path("..", "R code", "housekeeping.R"))

```

Data
------------------

We have data from [Baltimore city website](https://data.baltimorecity.gov), [Baltimore Neighborhood Indicators Alliance BNIA-JF](http://bniajfi.org), [Maryland department of planning](http://www.mdp.state.md.us/), and from the [Census Bureau](http://www.census.gov). The data consists of information about life expectancy estimates for each neighbourhood, along with crime, economic development and education informmation, all over a 5 year period (2010-2014). I also have street level, and [block group](https://www.census.gov/geo/reference/gtc/gtc_bg.html) level data. 

```{r data_download, include=FALSE, message=FALSE}

source(file = file.path("..", "R code", "Code_to_download_all_the_data_files.R"))

```

The data fall in three general categories.

  1. Street level 
  2. [Block group](https://www.census.gov/geo/reference/gtc/gtc_bg.html) level 
  3. [Community statistical area level (CSA)](http://bniajfi.org/faqs/)

###Data Cleaning and interpolation
The following table gives some of the variables used in the model fitting process, which level we originally got the data at and assumptions we made to get it at a street block level

| Variables | Name | Level | Cleaning steps |
|:----------:|:-----------:|:-----------:|:----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| propfemhh | Proportion of households headed by a female with related children under 18 years | Block group | Since the data was at a block group level and we were interested in getting street block level data, we used [Kriging](https://en.wikipedia.org/wiki/Kriging) to [interpolate](https://en.wikipedia.org/wiki/Interpolation) data at new locations (street block locations) using the information from the block group level. The locations for the street blocks were ascertained as the median longitude and latitude of all streets that made up the street block. One of the assumptions made here was that the distribution of the variable (propfemhh) was smooth in the sense that street blocks with such households will tend to be similar. |
| propkids_withinsurance | The proportion of individuals less than 18 years who have health insurance for a given block group | Block group | Here we used the block group value as the value for each street block in that block group. The assumption here was that block groups would tend to be quite homogenous with regard to this variable. |
| racdiv | Racial diversity as calculated per block group | Block group | This variable was not given but was estimated from the block group data on race. Its estimation proceeds as follows calculate the percent of each race, square the percent for each group, sum the squares, subtract the sum from 1.00. Eight groups were used for the index: White, not Hispanic; Black or African American; American Indian and Alaska Native (AIAN); Asian; Native Hawaiian and Other Pacific Islander (NHOPI); two or more races, not Hispanic; some other race, not Hispanic; Hispanic or Latino. This method is based on that used by the census bureau. More information can be found [here](http://www.census.gov/population/cen2000/atlas/censr01-104.pdf). We decided not to interpolate these values for the street blocks but instead used the values from block groups that they belonged to. This was done due to the unique structure of neighborhoods in Baltimore city.  |
| propbelow | Proportion of individuals within a block group that lives below the poverty line | Block group | To get the data at the street block level we interpolated values from the block group level. The assumption used here is that the further into a particular neighborhood you go, the more representative each block is of the aggregate level data for this variable. |
| mhhi | Median household income | Block group | We interpolated the values for the street blocks from the block group level data using Kriging. Again this is based on the assumption that the further into a particular neighborhood you go, the more representative each block is of the aggregate level data for this variable. |
| totalincidents  | # of crime incidents per street | Street | We aggregated this to get the number of crimes committed per street block |
| prop.vacant | Proportion of vacant homes | Street  | We divided the number of vacant homes per street block by the total number of homes in that street block.  |

The rest of the variables used in the final model includes: Percentage of Students Suspended or Expelled During School Year (susp); Liquor Outlet density per 1,000 Residents (liquor); and Percent of Residences Heated by Electricity (elheat). Note that all the variables mentioned above were observed at the CSA level. Furthermore, I did not do any interpolation for these variables at the street block level as I felt that the assumptions inherent in the process would be untenable.

## Descriptives

Since the goal of this analysis is to predict life expectancy at the street block level and since the block information contained in the dataset was not properly defined, I made a couple of plots to see what was census block and what was a street block.

Furthermore, since some of the data files have information on neighbourhood blocks, I plotted the Neighbourhood information as defined or delineated by the block level data gotten from the [Baltimore city website](https://data.baltimorecity.gov) and then overlayed the neighbourhood data gotten from the [Maryland department of planning](http://www.mdp.state.md.us/). Futhermore, using information from the [Baltimore gisdata website](http://gisdata.baltimorecity.gov) I was able to obtain what "block" was actually defined as. All of this points to the possiblity of using blocks from our dataset as street blocks.

```{r Plots, echo=FALSE, message=FALSE, cache.lazy=TRUE, eval=TRUE}
source(file = file.path("..", "R code", "block_plots.R"))
```

<!-- ![Neighbourhoods as defined by blocks using just block level data](../Plots/n_block_block.png) ![The fit of neighbourhood info on block data in Baltimore City](../Plots/block_block.png) ![Blocks in Baltimore City](../Plots/block_n.png)   -->

![](../Plots/block_b.png) 

Here the colored points are the street blocks, while the grids represents a census block. For more plots examining the fits please visit [my github repo](https://github.com/ksosina/BLE/tree/master/Plots)

```{r proof, echo=FALSE, message=FALSE,warning=FALSE}
##Need to install image magick else this won't work
real.prop <- read_csv(file.path("..","Data","raw_data", "real_property.csv.gz"))
random_block <- sample(real.prop$BLOCKPLAT,1)
if(!file.exists(file.path("..", "Plots", "random_block.pdf")))
{
  download(random_block, destfile = file.path("..", "Plots", "random_block.pdf"), mode = "wb")
}
# print(getwd())
# file.show(file.path("..", "Plots", "random_block.pdf"))
if(!file.exists(file.path("..", "Plots", "random_block.png")))
{
  animation::im.convert(file.path("..", "Plots", "random_block.pdf"), output = file.path("..", "Plots", "random_block.png"))
}

```

All of this indicate a good fit. I also used gis data from the [baltimore city website](http://gisdata.baltimorecity.gov/) and I found that each block was defined as a street block.[An example of a cityblock pulled from dataset](../Plots/random_block.png)

##Analysis
###Checking for Spatial correlation

Since we have spatial data I ran the both Mantel test[c.f @mantel1] and Moran's I [c.f @moran] to examine if spatial autocorrelation exists in this dataset. Please note that while both test measure spatial autocorrelation, they refer to quite different concepts.

Mantel's test[@mantel1; @mantel] gives correlation between different variables due to their spatial location, that is Mantel's test judges whether closeness in one set of variables is related to closeness in another set of variable. Relating this to our datasetwe can use it to see if samples that are close in terms of their geographic location values are also close in terms of life expectancy values. I.e test if the distance matrix based on life expectancy values is correlated with the distance matrix based on spatial location for the CSA's

```{r Mantel, echo=FALSE, cache=F, message=FALSE, warning=F}
source(file = file.path("..", "R code", "mantel.R"))
```

Based on these results, we can reject the null hypothesis that these two matrices, spatial distance and life expectancy distance (2014), are unrelated with alpha = 0.05.  The observed correlation, r = 0.13, suggests that the matrix entries are positively associated. So smaller differences in life expectancy are generally seen among pairs of CSA's that are close to each other than far from each other. Note that since this test is based on random permutations, the same code will always arrive at the same observed correlation but rarely the same p-value. Furthemore, I ran this test for all four years in the datset set and the conclusions are consistent. If you are interested in the correlation values for those years [here is the code](https://github.com/ksosina/BLE/blob/master/R%20code/check_sp_corr.R).

Moran's I[@moran] is useful when one wants to know the correlation of a variable with itself through space. I.e., when one wants to know to which extent the occurrence of an event in an areal unit makes it more likely or unlikely the occurrence of an event in a neighboring areal unit. I.e if life expectancy is low in the north does that mean that we likely to see low life expectancy in the same region? Thus the null is the lack of existence of spatial autocorrelation.
```{r Moran, echo=FALSE, cache=F, message=FALSE, warning=F}
source(file = file.path("..", "R code", "moran.R"))
```
Based on these results, we can reject the null hypothesis that there is zero spatial autocorrelation present in life expectancy at the 5\% level of significance. For more tests using data from 2011 to 2014 please check [here]((https://github.com/ksosina/BLE/blob/master/R%20code/check_sp_corr.R)).

###Regression Model for spatial data

```{r analyses_data, echo = F, message=FALSE, warning=F}
source(file = file.path("..", "R code", "analyses_data.R"))
```


####Geographically Weighted Regression (GWR)
* The structure of the model does not remain constant over the study area (there are local variations in the parameter estimates)
* To account for this potential spatial heterogeneity we use the GWR model [@fother]
* GWR permits the parameter estimates to vary locally.

#####GWR
This model uses a weighted least squares approach to account for spatial heteorgeniety and is as follows $$Y_i = X\beta_i +\epsilon$$ where $\beta_i$ is solved using the WLS approach. Thus $$\beta_i = (X^TW_iX)^{-1}X^TW_iY$$ where $W_i$ is the spatial weight matrix which is based on the distance between observations at location i. Using the approach of [@fother], $W(u_i,v_i)$ is an $n \times n$ diagonal matrix denoting the spatial weighting of each observation point for model calibration point i at location $(u_i,v_i)$. This can be specificed using three metrics: 1. The type of distance function used e.g the Great circle distance; 2. The kernel function, that is how to relate the distances; and 3. Its bandwidth, I.e how many neighborhoods to use. So for the jth element in $W(u_i,v_i)$ if we use the Gaussian kernel, we have that the $w_{ij}$ element is $$\exp\left(-\dfrac{1}{2}\left(\dfrac{d_{ij}}{b}\right)^2\right)$$.

####Model selection
#####Data
First I divided my data into a training and testing dataset. All the model selection procedures were then performed on the training dataset. To obtain candidate models to use for the GWR method, I used step wise model selection under four scenarios using the ordinary least squares regression approach

|                                           | Criteria = AIC | Criteria = BIC |
|-------------------------|:--------------:|:--------------:|
| Force variables in model selection  = Yes |       st1      |       st2      |
| Force variables in model selection = No   |       st3      |       st4      |

Where the variables that are forced are the aggregated CSA level variables for which we have street block level information. They include propfemhh, totalincidents, and prop.vacant. Based on this four models, I then selected the model that minimised the predictor error. I.e, the model with the best prediction performance. 

```{r modsel, echo = F, message=FALSE, warning=F}
source(file = file.path("..", "R code", "modsel.R"))
```



####Methods for Downscaling
* Delta method:
Here, after we find the model that fits the data best, using aggregated data. 

    1. We predict what the life expectancy would be after we remove one of the blocks from the aggregated data, call this $$ T_{-b} = E(Y)_{-b} $$ 
    2. Then we find the delta in predicted life expectancy at the CSA level due to the removed block as $$ T_{\delta_b} = T_{full} – T_{-b} $$ Call this delta the change in the mean life expectancy at the CSA level due to that block.
    3. Add the delta to the observed life expectancy at that CSA. Call this the predicted life expectancy due to that block.
    
Note that this inherently assumes that the observed life expectancy at a CSA is the true underlying life expectancy and that all the blocks in the neighborhoods that belong that CSA vary about it.

* Transfer function: Find which aggregated predictors provide the best fit, then use a "transfer function" to map the aggregated variables to the block level and use the value gotten as a predictor to get block level estimates. For this sceanario, I centered and scaled both the street block level data and the aggregated CSA level data, I.e I subtracted the mean of each variable (taken over the whole dataset) from itself and divided the centered variable by its standard deviation. By this my aim was to get estimates that were invariant to the fact that the CSA level data was an aggregated form of the street block level data. Then using the GWR model above, I predicted[@gwmodel] the life expectancy for a given street block. That is, $$Y_{pred_i} = W_i^{1/2}X_{block}\beta_i$$ breaking this down, this means that the predicted life expectancy for a given street block is a function of its distance from the CSA at location i (median longitude and latitude for all blocks in that CSA), the observed street block values at that street blocks location and the $\beta$ value of the CSA at location i.

```{r pred, echo=FALSE, message=FALSE, warning=FALSE,tidy=TRUE, include=TRUE, eval = T}
source(file = file.path("..", "R code", "prediction.R"))
```
![](../Plots/pred.png) 
The plot above shows what the observed life expectancy was in the testing dataset compared to the two methods mentioned above. The grey polygons represent CSA's that are in the training dataset, while the colored regions represent CSA's that are in the testing dataset.
 

## Datasets

| Name                                    | Information                                                                                                                                                                                                             | Type      | Data Source                                                                                          | Geographic Scale   | Date        |
|-----------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|------------------------------------------------------------------------------------------------------|--------------------|-------------|
| Real Property Taxes                     | Contains information on which streets belong to which block and in what neighbourhood along with their longitude and latitude. Also has information on police district.                                                 | Dataset   | [Baltimore city website](https://data.baltimorecity.gov)                                             | Street Level       | 2016        |
| Real Property                           | Contains the City of Baltimore parcel boundaries, with ownership, address, valuation and other property information. Furthermore, it also contains street block definitions.                                            | Dataset   | [Baltimore gisdata website](http://gisdata.baltimorecity.gov)                                        | Street level       | 2016        |
| Census Block                            | GIS shapefile which has information on census block designation for 2010                                                                                                                                                | Shapefile | [Maryland department of planning](http://planning.maryland.gov/msdc/S5_Map_GIS.Shtml)                | Block level        | 2010        |
| Neighborhoood                           | Polygon feature representing the boundaries of Baltimore City's neighborhoods as of the year 2010                                                                                                                       | Shapefile | [Baltimore city website](https://data.baltimorecity.gov)                                             | Neighborhood level | 2010        |
| Census Demographics for 2010 to 2014    | Contains neighborhood level demographics data                                                                                                                                                                           | Dataset   | [Baltimore Neighborhood Indicators Alliance BNIA-JF](http://bniajfi.org/vital_signs/data_downloads/) | Neighborhood level | 2010 - 2014 |
| Children and Family Health & Well-Being | Has information on life expectancy for 2010 to 2014                                                                                                                                                                     | Dataset   | [Baltimore Neighborhood Indicators Alliance BNIA-JF](http://bniajfi.org/vital_signs/data_downloads/) | Neighborhood level | 2010 - 2014 |
| BNIA Vital Signs Codebook               | Contain information on short variable names and their corresponding full names, along with their sources for each dataset                                                                                               | Dataset   | [Baltimore city website](https://data.baltimorecity.gov)                                             | Neighborhood level | 2016        |
| Housing and Community Development       | Has information on the state of households in Baltimore city, viz;Number of Homes Sold,Percentage of Residential Properties that are Vacant and Abandoned,Percent Residential Properties that do Not Receive Mail, etc. | Dataset   | [Baltimore Neighborhood Indicators Alliance BNIA-JF](http://bniajfi.org/vital_signs/data_downloads/) | Neighborhood level | 2010-2014   |
| BNIA Data linking CSA to Neighborhoods      | Has information on which neighborhoods belong to what CSA. Note that a neighborhood may belong to more than one CSA | Dataset   | [Baltimore Neighborhood Indicators Alliance BNIA-JF](http://bniajfi.org/mapping-resources/) | CSA and Neighborhood level | 2010   |
| Census Bureau    | Has information at the block group level. This includes information on family types, poverty status, the median househoold income  | Dataset   | [ American FactFinder](https://www.census.gov/acs/www/data/data-tables-and-tools/american-factfinder/) | Census tract and Block group level | 2014 |



```{r version info}
devtools::session_info()
```

# References
